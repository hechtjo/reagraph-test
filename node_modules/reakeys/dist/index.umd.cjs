(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("mousetrap")) : typeof define === "function" && define.amd ? define(["exports", "react", "mousetrap"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.reakeys = {}, global.react, global.Mousetrap));
})(this, function(exports2, react, Mousetrap) {
  "use strict";
  const createStateHook = () => {
    const mousetraps = /* @__PURE__ */ new Map();
    let keys = [];
    const bindKeys = (nextKeys) => {
      nextKeys.forEach((k) => {
        if (k.disabled) {
          return;
        }
        if (k.ref) {
          if (!k.ref.current) {
            return;
          }
          const element = k.ref.current;
          if (!mousetraps.has(element)) {
            mousetraps.set(element, new Mousetrap(element));
          }
          mousetraps.get(element).bind(k.keys, k.callback, k.action);
        } else {
          if (!mousetraps.get(void 0)) {
            mousetraps.set(void 0, Mousetrap);
          }
          mousetraps.get(void 0).bind(k.keys, k.callback, k.action);
        }
      });
    };
    const addKeys = (nextKeys) => {
      keys = [...keys, ...nextKeys];
      bindKeys(nextKeys);
    };
    const removeKeys = (nextKeys) => {
      keys = keys.filter((k) => !nextKeys.includes(k));
      nextKeys.forEach((k) => {
        var _a, _b;
        if (k.ref) {
          if (!k.ref.current) {
            return;
          }
          (_a = mousetraps.get(k.ref.current)) == null ? void 0 : _a.unbind(k.keys, k.action);
        } else {
          (_b = mousetraps.get(void 0)) == null ? void 0 : _b.unbind(k.keys, k.action);
        }
      });
      for (const [element] of mousetraps) {
        if (element === void 0) {
          if (keys.some((k) => k.ref === void 0)) {
            continue;
          }
        } else {
          if (keys.some((k) => {
            var _a;
            return ((_a = k.ref) == null ? void 0 : _a.current) === element;
          })) {
            continue;
          }
        }
        mousetraps.delete(element);
      }
      bindKeys(keys);
    };
    return () => {
      const [state, setState] = react.useState([]);
      react.useEffect(() => {
        setState(keys);
      }, []);
      return [state, addKeys, removeKeys];
    };
  };
  const useHotkeyState = createStateHook();
  const useHotkeys = (shortcuts) => {
    const [keys, addKeys, removeKeys] = useHotkeyState();
    react.useLayoutEffect(() => {
      if (shortcuts) {
        addKeys(shortcuts);
      }
      return () => {
        if (shortcuts) {
          removeKeys(shortcuts);
        }
      };
    }, [addKeys, removeKeys, shortcuts]);
    return react.useMemo(
      () => keys.reduce((agg, cur) => {
        if (!agg.find((a) => a.keys === cur.keys && a.ref && cur.ref)) {
          agg.push(cur);
        }
        return agg;
      }, []),
      [keys]
    );
  };
  let isMac = false;
  try {
    if (navigator)
      isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
  } catch (e) {
    console.warn(e);
  }
  const MODIFIER_KEY = isMac ? "⌘" : "CTRL";
  function getHotkeyText(hotkey) {
    return hotkey.replace("modifier", MODIFIER_KEY).replace("mod", MODIFIER_KEY).replace("shift", "⇧");
  }
  exports2.MODIFIER_KEY = MODIFIER_KEY;
  exports2.getHotkeyText = getHotkeyText;
  exports2.useHotkeyState = useHotkeyState;
  exports2.useHotkeys = useHotkeys;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=index.umd.cjs.map
